{
  "entities": {
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user in the bakery canteen system.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the user."
        },
        "name": {
          "type": "string",
          "description": "The name of the user."
        },
        "creditBalance": {
          "type": "number",
          "description": "The current credit balance of the user."
        },
        "lastOrderNo": {
          "type": "string",
          "description": "The order number of the user's last order."
        }
      },
      "required": [
        "id",
        "name",
        "creditBalance"
      ]
    },
    "Order": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Order",
      "type": "object",
      "description": "Represents an order placed in the bakery canteen system.",
      "properties": {
        "orderNumber": {
          "type": "string",
          "description": "Unique identifier for the order."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N Order)"
        },
        "items": {
          "type": "array",
          "description": "A list of item IDs in the order. References Inventory. (Relationship: Order N:N Inventory)",
          "items": {
            "type": "string"
          }
        },
        "amount": {
          "type": "number",
          "description": "The total amount of the order."
        },
        "timestamp": {
          "type": "string",
          "description": "The timestamp of when the order was placed.",
          "format": "date-time"
        }
      },
      "required": [
        "orderNumber",
        "userId",
        "items",
        "amount",
        "timestamp"
      ]
    },
    "Inventory": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Inventory",
      "type": "object",
      "description": "Represents an item in the bakery canteen's inventory.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the inventory item."
        },
        "itemName": {
          "type": "string",
          "description": "The name of the inventory item."
        },
        "currentAmount": {
          "type": "number",
          "description": "The current amount of the item in stock."
        },
        "threshold": {
          "type": "number",
          "description": "The threshold amount for the item, below which an alert is triggered."
        }
      },
      "required": [
        "id",
        "itemName",
        "currentAmount",
        "threshold"
      ]
    },
    "Dashboard": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Dashboard",
      "type": "object",
      "description": "Represents the dashboard data for the bakery canteen system.",
      "properties": {
        "dailySalesCount": {
          "type": "number",
          "description": "The total sales count for the current day."
        },
        "mostSoldItems": {
          "type": "array",
          "description": "A list of the most sold item IDs. References Inventory. (Relationship: Dashboard 1:N Inventory)",
          "items": {
            "type": "string"
          }
        },
        "totalCredit": {
          "type": "number",
          "description": "The total credit available in the system."
        }
      },
      "required": [
        "dailySalesCount",
        "mostSoldItems",
        "totalCredit"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user data. Includes user ID, name, credit balance, and last order number.",
          "params": [
            {
              "name": "userId",
              "description": "Unique identifier for the user."
            }
          ]
        }
      },
      {
        "path": "/orders/{orderNumber}",
        "definition": {
          "entityName": "Order",
          "schema": {
            "$ref": "#/backend/entities/Order"
          },
          "description": "Stores order data. Includes order number, user ID, items, amount, and timestamp.",
          "params": [
            {
              "name": "orderNumber",
              "description": "Unique identifier for the order."
            }
          ]
        }
      },
      {
        "path": "/inventory/{inventoryId}",
        "definition": {
          "entityName": "Inventory",
          "schema": {
            "$ref": "#/backend/entities/Inventory"
          },
          "description": "Stores inventory item data. Includes item name, current amount, and threshold.",
          "params": [
            {
              "name": "inventoryId",
              "description": "Unique identifier for the inventory item."
            }
          ]
        }
      },
      {
        "path": "/dashboard/canteen_dashboard",
        "definition": {
          "entityName": "Dashboard",
          "schema": {
            "$ref": "#/backend/entities/Dashboard"
          },
          "description": "Stores dashboard data. Includes daily sales count, most sold items, and total credit. Uses a fixed document ID 'canteen_dashboard'.",
          "params": []
        }
      }
    ],
    "reasoning": "The Firestore data structure is designed to support the bakery canteen automation system, focusing on simplicity and scalability.  The structure is segregated into collections for users, orders, inventory, and dashboard data. The key principle here is **Authorization Independence**. Since this is an admin-only system with no user authentication (anonymous authentication is used, but no user-level authorization), we don't need to denormalize any authorization data.\n\n**QAPs Support:**\n*   **List Operations:** The segregated structure inherently supports secure `list` operations. Each collection can be queried independently without needing complex filtering based on authorization.\n*   **Admin-Only Access:** Since the application is for internal use and there's no individual user authentication implemented in the rules, the rules can be written to allow only authenticated users (via anonymous auth, meaning the app itself) to read and write data, which satisfies QAPs in this context.\n\nBecause the app is explicitly described as `admin-only`, security rules can ensure only authenticated clients can read and write, preventing unauthorized data access."
  }
}